            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            encoding='utf-8',
            errors='replace'
        )
        
        # Read output in real-time
        stdout, stderr = process.communicate()
        
        # Check for errors
        if process.returncode != 0:
            # Read the log file for detailed error
            try:
                with open(log_file, 'r', encoding='utf-8', errors='replace') as f:
                    log_content = f.read()
                error_msg = f"Erreur lors de la comparaison des documents Word.\n\nDétails :\n{log_content}"
            except Exception as e:
                error_msg = f"Erreur lors de la lecture du journal d'erreur : {str(e)}"
                
            if not error_msg.strip():
                error_msg = "Erreur inconnue lors de la comparaison des documents Word."
                
            raise RuntimeError(error_msg)
            
    except subprocess.CalledProcessError as e:
        # Read the log file for detailed error
        try:
            with open(log_file, 'r', encoding='utf-8', errors='replace') as f:
                log_content = f.read()
            error_msg = f"Erreur lors de l'exécution de PowerShell :\n{log_content}"
        except Exception as e:
            error_msg = f"Erreur lors de la lecture du journal d'erreur : {str(e)}"
        
        raise RuntimeError(error_msg) from e
        
    except Exception as e:
        raise RuntimeError(f"Erreur inattendue : {str(e)}") from e
        
    finally:
        # Clean up the temporary log file
        try:
            if os.path.exists(log_file):
                os.unlink(log_file)
        except Exception:
            pass


# ---------------------- Fenêtre de sélection ----------------------

class SectionsDialog(tk.Toplevel):
    def __init__(self, master, sections, preselected_idx=None):
        super().__init__(master)
        self.title("Sélection des sections")
        self.geometry("560x420")
        self.resizable(True, True)
        self.sections = sections
        self.result = None
        self.selected = set(preselected_idx or [])

        frm = tk.Frame(self)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        # Listbox multisélection (EXTENDED => Shift pour plage, Ctrl pour ajout)
        self.lb = tk.Listbox(frm, selectmode=tk.EXTENDED, activestyle="none")
        sb = ttk.Scrollbar(frm, orient="vertical", command=self.lb.yview)
        self.lb.configure(yscrollcommand=sb.set)
        self.lb.pack(side="left", fill="both", expand=True)
        sb.pack(side="right", fill="y")

        # Remplir
        for i, s in enumerate(sections):
            indent = "    " * (max(0, s.level - 1))
            self.lb.insert(tk.END, f"{indent}{s.label()}")
            if i in self.selected:
                self.lb.selection_set(i)
        # Click sans modificateur => sélectionner le bloc (section + descendants)
        self.lb.bind("<ButtonRelease-1>", self.on_click_block)

        # Actions
        btns = tk.Frame(self)
        btns.pack(fill="x", padx=10, pady=(0, 10))
        tk.Button(btns, text="Tout cocher", command=self.sel_all).pack(side="left")
        tk.Button(btns, text="Tout décocher", command=self.sel_none).pack(side="left", padx=6)
        tk.Button(btns, text="Valider", command=self.on_ok).pack(side="right")
        tk.Button(btns, text="Annuler", command=self.on_cancel).pack(side="right", padx=6)

        self.bind("<Return>", lambda e: self.on_ok())
        self.bind("<Escape>", lambda e: self.on_cancel())
        self.transient(master)
        self.grab_set()
        self.lb.focus_set()

    def sel_all(self):
        self.lb.select_set(0, tk.END)

    def sel_none(self):
        self.lb.select_clear(0, tk.END)

    def on_ok(self):
        self.result = list(self.lb.curselection())
        self.destroy()

    def on_cancel(self):
        self.result = None
        self.destroy()

    def on_click_block(self, event):
        # Respecter Shift/Ctrl (sélection étendue native)
        shift = (event.state & 0x0001) != 0
        ctrl = (event.state & 0x0004) != 0
        if shift or ctrl:
            return
        idx = self.lb.nearest(event.y)
        if idx < 0:
            return
        # Déterminer le bloc [idx .. endDesc]
        cur_level = self.sections[idx].level
        end = idx + 1
        while end < len(self.sections) and self.sections[end].level > cur_level:
            end += 1
        block = range(idx, end)
        # Toggle du bloc (si tout déjà sélectionné -> on désélectionne)
        sel = set(self.lb.curselection())
        if all(i in sel for i in block):
            for i in block:
                self.lb.selection_clear(i)
        else:
            # Remplacer par défaut (comportement simple et prévisible)
            self.lb.selection_clear(0, tk.END)
            for i in block:
                self.lb.selection_set(i)


# ------------------------- GUI -------------------------


class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Relecture IA — Assistant graphique")
        self.geometry("1000x760")
        self.resizable(True, True)

        self.source_path = None  # chemin vers le fichier source original
        self.copy_relpath = None  # chemin relatif vers la copie dans input/
        self.output_dir = OUTPUT_DIR  # dossier de sortie choisi
        self.mode = None  # 'offre'|'diagnostic'|'impacts'|'mesures'

        self.sections = []  # list[Section]
        self.section_vars = []  # list[tk.BooleanVar]

        self._build_ui()

    # --- deps ---
    def ensure_docx(self) -> bool:
        global Document
        if Document is not None:
            return True
        try:
