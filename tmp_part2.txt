            parts = raw.split(" ", 1)
            title = sanitize_text(parts[1] if len(parts) > 1 else raw.lstrip("#"))
            revised_lines.append(parts[0] + " " + title)
            continue
        cleaned = sanitize_text(raw)
        revised_lines.append(cleaned)

        txt_low = cleaned.lower()
        make_comment = None
        if len(cleaned) > 600:
            make_comment = ("P3", "redaction", "Paragraphe très long: envisager de le scinder pour la lisibilité.")
        if any(x in txt_low for x in ["tbd", "???", "à définir", "a definir", "xxx"]):
            make_comment = ("P1", "coherence", "Marqueur d'incertain repéré (TBD/??/à définir): préciser ou retirer.")
        if ("carte" in txt_low or "figure" in txt_low) and not re.search(r"\b(\d+)\b", cleaned):
            make_comment = ("P3", "carto", "Référence à une carte/figure sans identifiant: ajouter le numéro.")

        if make_comment:
            grav, cat, note = make_comment
            if cat not in ALLOWED_CATEGORIES:
                cat = "redaction"
            comments.append(
                {
                    "ancre_textuelle": anchor_for(cleaned[:80]),
                    "commentaire": note,
                    "gravite": grav,
                    "categorie": cat,
                }
            )

    revised_md = "\n".join(revised_lines) + "\n"
    return revised_md, comments


def markdown_to_docx(md_text: str, out_path: str):
    doc = Document()
    for raw in md_text.splitlines():
        if not raw.strip():
            doc.add_paragraph("")
            continue
        if raw.startswith("#"):
            level = len(raw) - len(raw.lstrip("#"))
            title = raw[level:].strip()
            p = doc.add_paragraph(title)
            try:
                p.style = f"Heading {min(level,6)}"
            except Exception:
                pass
        elif raw.startswith("- "):
            doc.add_paragraph(raw[2:])
        else:
            doc.add_paragraph(raw)
    doc.save(out_path)


def write_comments_csv(rows, path: str):
    fieldnames = ["ancre_textuelle", "commentaire", "gravite", "categorie"]
    norm_rows = []
    for r in rows:
        rr = {k: str(r.get(k, "")) for k in fieldnames}
        if rr["gravite"] not in ("P1", "P2", "P3"):
            rr["gravite"] = "P3"
        if rr["categorie"] not in ALLOWED_CATEGORIES:
            rr["categorie"] = "redaction"
        if rr["ancre_textuelle"]:
            norm_rows.append(rr)
    with open(path, "w", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        for r in norm_rows:
            w.writerow(r)


def run_compare_and_comment(original_docx: str, revised_docx: str, comments_csv: str, output_docx: str):
    ps1 = os.path.join(ROOT, "tools", "compare_and_comment.ps1")
    if not os.path.exists(ps1):
        raise RuntimeError("tools/compare_and_comment.ps1 manquant")
    os.makedirs(os.path.dirname(output_docx), exist_ok=True)
    cmd = [
        "powershell",
        "-ExecutionPolicy",
        "Bypass",
        "-File",
        ps1,
        "-OriginalDocx",
        original_docx,
        "-RevisedDocx",
        revised_docx,
        "-CommentsCsv",
        comments_csv,
        "-OutputDocx",
        output_docx,
    ]
    subprocess.run(cmd, check=True)


# ---------------------- Fenêtre de sélection ----------------------

class SectionsDialog(tk.Toplevel):
    def __init__(self, master, sections, preselected_idx=None):
        super().__init__(master)
        self.title("Sélection des sections")
        self.geometry("560x420")
        self.resizable(True, True)
        self.sections = sections
        self.result = None
        self.selected = set(preselected_idx or [])

        frm = tk.Frame(self)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        # Listbox multisélection (EXTENDED => Shift pour plage, Ctrl pour ajout)
        self.lb = tk.Listbox(frm, selectmode=tk.EXTENDED, activestyle="none")
        sb = ttk.Scrollbar(frm, orient="vertical", command=self.lb.yview)
        self.lb.configure(yscrollcommand=sb.set)
        self.lb.pack(side="left", fill="both", expand=True)
        sb.pack(side="right", fill="y")

        # Remplir
        for i, s in enumerate(sections):
            indent = "    " * (max(0, s.level - 1))
            self.lb.insert(tk.END, f"{indent}{s.label()}")
            if i in self.selected:
                self.lb.selection_set(i)
        # Click sans modificateur => sélectionner le bloc (section + descendants)
        self.lb.bind("<ButtonRelease-1>", self.on_click_block)

        # Actions
        btns = tk.Frame(self)
        btns.pack(fill="x", padx=10, pady=(0, 10))
        tk.Button(btns, text="Tout cocher", command=self.sel_all).pack(side="left")
        tk.Button(btns, text="Tout décocher", command=self.sel_none).pack(side="left", padx=6)
        tk.Button(btns, text="Valider", command=self.on_ok).pack(side="right")
        tk.Button(btns, text="Annuler", command=self.on_cancel).pack(side="right", padx=6)

        self.bind("<Return>", lambda e: self.on_ok())
        self.bind("<Escape>", lambda e: self.on_cancel())
        self.transient(master)
        self.grab_set()
        self.lb.focus_set()

    def sel_all(self):
        self.lb.select_set(0, tk.END)

    def sel_none(self):
        self.lb.select_clear(0, tk.END)

    def on_ok(self):
        self.result = list(self.lb.curselection())
        self.destroy()

    def on_cancel(self):
        self.result = None
        self.destroy()

    def on_click_block(self, event):
        # Respecter Shift/Ctrl (sélection étendue native)
        shift = (event.state & 0x0001) != 0
        ctrl = (event.state & 0x0004) != 0
        if shift or ctrl:
            return
        idx = self.lb.nearest(event.y)
        if idx < 0:
            return
        # Déterminer le bloc [idx .. endDesc]
        cur_level = self.sections[idx].level
        end = idx + 1
        while end < len(self.sections) and self.sections[end].level > cur_level:
            end += 1
        block = range(idx, end)
        # Toggle du bloc (si tout déjà sélectionné -> on désélectionne)
        sel = set(self.lb.curselection())
        if all(i in sel for i in block):
            for i in block:
                self.lb.selection_clear(i)
        else:
            # Remplacer par défaut (comportement simple et prévisible)
            self.lb.selection_clear(0, tk.END)
            for i in block:
                self.lb.selection_set(i)


# ------------------------- GUI -------------------------


class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Relecture IA — Assistant graphique")
        self.geometry("1000x760")
        self.resizable(True, True)

        self.source_path = None  # chemin vers le fichier source original
        self.copy_relpath = None  # chemin relatif vers la copie dans input/
        self.output_dir = OUTPUT_DIR  # dossier de sortie choisi
        self.mode = None  # 'offre'|'diagnostic'|'impacts'|'mesures'

        self.sections = []  # list[Section]
        self.section_vars = []  # list[tk.BooleanVar]

        self._build_ui()

    # --- deps ---
    def ensure_docx(self) -> bool:
        global Document
        if Document is not None:
            return True
        try:
            import importlib
            Document = importlib.import_module('docx').Document
            return True
        except Exception:
            pass
        # Try on-the-fly install
        try:
            self.log("Installation de python-docx (et lxml)…")
            subprocess.run([sys.executable, "-m", "pip", "install", "python-docx", "lxml"], check=True)
            import importlib
            Document = importlib.import_module('docx').Document
            self.log("python-docx installé avec succès.")
            return True
        except Exception as e:
            self.log(f"Échec installation python-docx: {e}")
            return False

    def log(self, msg: str):
        self.log_txt.configure(state="normal")
        self.log_txt.insert(tk.END, f"{datetime.now().strftime('%H:%M:%S')} — {msg}\n")
        self.log_txt.see(tk.END)
        self.log_txt.configure(state="disabled")
        self.update_idletasks()

    def _build_ui(self):
        pad = {"padx": 10, "pady": 8}

        # 1) Fichier source
        frame1 = tk.LabelFrame(self, text="1) Fichier source")
        frame1.pack(fill="x", **pad)
        self.src_var = tk.StringVar(value="Aucun fichier sélectionné")
        tk.Label(frame1, textvariable=self.src_var, anchor="w").pack(fill="x", padx=10, pady=5)
        btns1 = tk.Frame(frame1)
        btns1.pack(anchor="w", padx=10, pady=5)
        tk.Button(btns1, text="Sélectionner le fichier Word…", command=self.choose_source).pack(side="left", padx=5)
        tk.Button(btns1, text="Ouvrir le dossier", command=self.open_source_folder).pack(side="left", padx=5)
        tk.Label(
            frame1,
            text="Le fichier original ne sera jamais modifié. Le traitement s’effectue sur une copie.",
            fg="#555",
        ).pack(anchor="w", padx=10, pady=5)

        # 2) Sections du document
