def run_compare_and_comment(original_docx: str, revised_docx: str, comments_csv: str, output_docx: str):
    """Run the PowerShell compare script and surface detailed errors.

    Uses -NoProfile and captures stdout/stderr so that any failure inside
    PowerShell/Word is clearly shown to the user instead of only the exit code.
    Also normalizes paths to avoid issues with spaces, accents and '&'.
    """
    ps1 = os.path.join(os.path.dirname(__file__), "tools/compare_and_comment.ps1")
    if not os.path.exists(ps1):
        raise RuntimeError("Le fichier tools/compare_and_comment.ps1 est manquant")

    # Ensure output directory exists
    os.makedirs(os.path.dirname(output_docx), exist_ok=True)

    # Normalize to absolute paths
    ps1 = os.path.normpath(os.path.abspath(ps1))
    original_docx = os.path.normpath(os.path.abspath(original_docx))
    revised_docx = os.path.normpath(os.path.abspath(revised_docx))
    comments_csv = os.path.normpath(os.path.abspath(comments_csv))
    output_docx = os.path.normpath(os.path.abspath(output_docx))

    # Quick sanity checks for clearer error messages
    for p, label in [
        (original_docx, "Document original"),
        (revised_docx, "Document révisé"),
        (comments_csv, "Fichier CSV des commentaires"),
    ]:
        if not os.path.exists(p):
            raise RuntimeError(f"Fichier introuvable pour {label}: {p}")

    # Create a temporary file for PowerShell output
    import tempfile
    with tempfile.NamedTemporaryFile(delete=False, suffix='.log') as tmp:
        log_file = tmp.name

    try:
        # Build the PowerShell command with proper encoding
        cmd = [
            'powershell.exe',
            '-NoProfile',
            '-ExecutionPolicy', 'Bypass',
            '-NoLogo',
            '-NonInteractive',
            '-Command',
            f'$ErrorActionPreference = "Stop"; ' \
            f'$OutputEncoding = [System.Text.Encoding]::UTF8; ' \
            f'try {{ ' \
            f'    & "{ps1}" -OriginalDocx "{original_docx}" -RevisedDocx "{revised_docx}" -CommentsCsv "{comments_csv}" -OutputDocx "{output_docx}" 2>&1 | ' \
            f'    Tee-Object -FilePath "{log_file}" -Encoding UTF8 ' \
            f'}} catch {{ ' \
            f'    [System.Console]::Error.WriteLine($_.Exception.Message); ' \
            f'    exit 1 ' \
            f'}}'
        ]
        
        # Run the command with proper encoding
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            encoding='utf-8',
            errors='replace'
        )
        
        # Read output in real-time
        stdout, stderr = process.communicate()
        
        # Check for errors
        if process.returncode != 0:
            # Read the log file for detailed error
            try:
                with open(log_file, 'r', encoding='utf-8', errors='replace') as f:
                    log_content = f.read()
                error_msg = f"Erreur lors de la comparaison des documents Word.\n\nDétails :\n{log_content}"
            except Exception as e:
                error_msg = f"Erreur lors de la lecture du journal d'erreur : {str(e)}"
                
            if not error_msg.strip():
                error_msg = "Erreur inconnue lors de la comparaison des documents Word."
                
            raise RuntimeError(error_msg)
            
    except subprocess.CalledProcessError as e:
        # Read the log file for detailed error
        try:
            with open(log_file, 'r', encoding='utf-8', errors='replace') as f:
                log_content = f.read()
            error_msg = f"Erreur lors de l'exécution de PowerShell :\n{log_content}"
        except Exception as e:
            error_msg = f"Erreur lors de la lecture du journal d'erreur : {str(e)}"
        
        raise RuntimeError(error_msg) from e
        
    except Exception as e:
        raise RuntimeError(f"Erreur inattendue : {str(e)}") from e
        
    finally:
        # Clean up the temporary log file
        try:
            if os.path.exists(log_file):
                os.unlink(log_file)
        except Exception:
            pass


# ---------------------- Fenêtre de sélection ----------------------

class SectionsDialog(tk.Toplevel):
    def __init__(self, master, sections, preselected_idx=None):
        super().__init__(master)
        self.title("Sélection des sections")
        self.geometry("560x420")
        self.resizable(True, True)
        self.sections = sections
        self.result = None
        self.selected = set(preselected_idx or [])

        frm = tk.Frame(self)
        frm.pack(fill="both", expand=True, padx=10, pady=10)

        # Listbox multisélection (EXTENDED => Shift pour plage, Ctrl pour ajout)
        self.lb = tk.Listbox(frm, selectmode=tk.EXTENDED, activestyle="none")
        sb = ttk.Scrollbar(frm, orient="vertical", command=self.lb.yview)
        self.lb.configure(yscrollcommand=sb.set)
        self.lb.pack(side="left", fill="both", expand=True)
        sb.pack(side="right", fill="y")

        # Remplir
        for i, s in enumerate(sections):
            indent = "    " * (max(0, s.level - 1))
            self.lb.insert(tk.END, f"{indent}{s.label()}")
            if i in self.selected:
                self.lb.selection_set(i)
        # Click sans modificateur => sélectionner le bloc (section + descendants)
        self.lb.bind("<ButtonRelease-1>", self.on_click_block)

        # Actions
        btns = tk.Frame(self)
        btns.pack(fill="x", padx=10, pady=(0, 10))
        tk.Button(btns, text="Tout cocher", command=self.sel_all).pack(side="left")
        tk.Button(btns, text="Tout décocher", command=self.sel_none).pack(side="left", padx=6)
        tk.Button(btns, text="Valider", command=self.on_ok).pack(side="right")
        tk.Button(btns, text="Annuler", command=self.on_cancel).pack(side="right", padx=6)

        self.bind("<Return>", lambda e: self.on_ok())
        self.bind("<Escape>", lambda e: self.on_cancel())
        self.transient(master)
        self.grab_set()
        self.lb.focus_set()

    def sel_all(self):
        self.lb.select_set(0, tk.END)

    def sel_none(self):
        self.lb.select_clear(0, tk.END)

    def on_ok(self):
        self.result = list(self.lb.curselection())
        self.destroy()

    def on_cancel(self):
        self.result = None
        self.destroy()

    def on_click_block(self, event):
        # Respecter Shift/Ctrl (sélection étendue native)
        shift = (event.state & 0x0001) != 0
        ctrl = (event.state & 0x0004) != 0
        if shift or ctrl:
            return
        idx = self.lb.nearest(event.y)
        if idx < 0:
            return
        # Déterminer le bloc [idx .. endDesc]
        cur_level = self.sections[idx].level
        end = idx + 1
        while end < len(self.sections) and self.sections[end].level > cur_level:
            end += 1
        block = range(idx, end)
        # Toggle du bloc (si tout déjà sélectionné -> on désélectionne)
        sel = set(self.lb.curselection())
        if all(i in sel for i in block):
            for i in block:
                self.lb.selection_clear(i)
        else:
            # Remplacer par défaut (comportement simple et prévisible)
            self.lb.selection_clear(0, tk.END)
            for i in block:
                self.lb.selection_set(i)


# ------------------------- GUI -------------------------


class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Relecture IA — Assistant graphique")
        self.geometry("1000x760")
        self.resizable(True, True)

        self.source_path = None  # chemin vers le fichier source original
        self.copy_relpath = None  # chemin relatif vers la copie dans input/
        self.output_dir = OUTPUT_DIR  # dossier de sortie choisi
        self.mode = None  # 'offre'|'diagnostic'|'impacts'|'mesures'

        self.sections = []  # list[Section]
        self.section_vars = []  # list[tk.BooleanVar]

        self._build_ui()

    # --- deps ---
    def ensure_docx(self) -> bool:
        global Document
        if Document is not None:
            return True
        try:
            import importlib
